<!DOCTYPE HTML>
<html>
<head>
<title>InStr()</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="../static/theme.css" rel="stylesheet" type="text/css" />
<script src="../static/ga.js" type="text/javascript"></script>
<script src="../static/content.js" type="text/javascript"></script>
</head>
<body>

<h1>InStr()</h1>

<p>Sucht eine bestimmte Zeichenkette, beginnend von links oder rechts.</p>

<pre class="Syntax">Fundposition := InStr(Heuhaufen, Nadel [, Zeichengenauigkeit = false, Startposition = 1, Vorkommen = 1])</pre>
<h3>Parameter</h3>
<dl>

  <dt>Fundposition</dt>
  <dd><p>Gibt die Position der Zeichenkette <em>Nadel</em> zurück, die in der Zeichenkette <em>Heuhaufen</em> vorkommt. Position 1 ist das erste Zeichen; das liegt daran, dass 0 das Synonym für "falsch" ist, was sich gut als "nicht gefunden" eignet.</p></dd>

  <dt>Heuhaufen</dt>
  <dd><p>Eine Zeichenkette, deren Inhalt durchsucht werden soll.</p></dd>
  
  <dt>Nadel</dt>
  <dd><p>Der zu suchende Text.</p></dd>
  
  <dt>Zeichengenauigkeit</dt>
  <dd><p>Ist der <em>Zeichengenauigkeit</em>-Parameter nicht vorhanden oder "falsch", unterscheidet die Suche nicht zwischen Groß- und Kleinschreibung (die Unterscheidung hängt von <a href="StringCaseSense.htm">StringCaseSense</a> ab); ansonsten muss die Groß- und Kleinschreibung exakt übereinstimmen.</p></dd>

  <dt>Startposition</dt>
  <dd><p>Ist <em>Startposition</em> nicht vorhanden, gilt standardmäßig 1 (der Anfang von <em>Heuhaufen</em>). Ansonsten kann eine 2 angegeben werden, um beim zweiten Zeichen zu beginnen, eine 3, um beim dritten Zeichen zu beginnen, und so weiter.</p>
      <p>Überschreitet <em>Startposition</em> die Länge von <em>Heuhaufen</em>, wird eine 0 zurückgegeben. <span class="ver">[AHK_L 57+]:</span> Wenn <em>Startposition</em> eine 0 oder negativ ist, erfolgt die Suche in umgekehrter Reihenfolge (von rechts nach links), beginnend beim Offset am Ende.</p>
      <p>Egal welchen Wert man als <em>Startposition</em> verwendet - der Rückgabewert ist immer relativ zum ersten <em>Heuhaufen</em>-Zeichen. Zum Beispiel wäre die Position von "abc" in "123abc789" immer 4.</p></dd>

  <dt>Vorkommen <span class="ver">[AHK_L 57+]</span></dt>
  <dd><p>Fehlt <em>Vorkommen</em>, gilt standardmäßig die erste Übereinstimmung von <em>Nadel</em> in <em>Heuhaufen</em>. Schreibe eine 2 in <em>Vorkommen</em>, um die Position der zweiten Übereinstimmung zurückzugeben, eine 3 für die dritte Übereinstimmung und so weiter.</p></dd>

  </dl>

<h3>Bemerkungen</h3>
<p>Diese Funktion ist eine Kombination aus <a href="StringCaseSense.htm">IfInString</a> und <a href="StringCaseSense.htm">StringGetPos</a>, und eine vereinfachte Form von <a href="RegExMatch.htm">RegExMatch()</a>.</p>
<p>Diese Funktion ist in der Regel schneller als <a href="RegExMatch.htm">RegExMatch()</a>, wenn es darum geht, eine Zeichenkette in einer größeren Zeichenkette zu suchen.</p>

<h3>Siehe auch</h3>
<p><a href="RegExMatch.htm">RegExMatch()</a>, <a href="StringGetPos.htm">StringGetPos</a>, <a href="StringCaseSense.htm">IfInString</a>, <a href="StringCaseSense.htm">StringCaseSense</a>, <a href="IfIn.htm">if Var in/contains Vergleichsliste</a>, <a href="IfBetween.htm">if Var between</a>, <a href="IfIs.htm">if Var is Typ</a>
<h3>Beispiel</h3>
<pre class="NoIndent"><em>; Beispiel 1</em>
MsgBox % InStr("123abc789","abc") <em>; Gibt 4 zurück</em>

<em>; Beispiel 2</em>
Heuhaufen := "The Quick Brown Fox Jumps Over the Lazy Dog"
Nadel := "Fox"
If InStr(Heuhaufen, Nadel)
  MsgBox, Zeichenkette gefunden.
Else
  MsgBox, Zeichenkette nicht gefunden.

<em>; Beispiel 3</em>
Heuhaufen := "The Quick Brown Fox Jumps Over the Lazy Dog"
Nadel := "the"
MsgBox % InStr(Heuhaufen, Nadel, false, 1, 2) <em>; zeichenungenaue Suche, gibt die Startposition des zweiten Vorkommens zurück</em>
MsgBox % InStr(Haystack, Needle, true) <em>; zeichengenaue Suche, gibt die Startposition des ersten Vorkommens zurück, das gleiche Ergebnis wie oben</em>
</pre>

</body>
</html>
